/**
 * @author Stefano Ceccotti
*/

package distributed_fs.overlay.manager.anti_entropy;

import static distributed_fs.overlay.manager.anti_entropy.MerkleTree.LEAF_SIG_TYPE;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

import distributed_fs.overlay.manager.anti_entropy.MerkleTree.Node;

/**
 * The Deserialization code was separated from the MerkleTree class.
*/
public final class MerkleDeserializer
{
	/**
	 * Deserialize works from a byte array generated by {@link MerkleTree#serialize()}.
	 * Serialization format:
	 * (magicheader:int)(numnodes:int)[(nodetype:byte)(siglength:int)(signature:byte[])]
	 * 
	 * @param serializedTree
	 * 
	 * @return the Merkle tree
	*/
	public static MerkleTree deserializeTree( final byte[] serializedTree )
	{
		ByteBuffer buf = ByteBuffer.wrap( serializedTree );
		
		/* ---[ read header ]--- */
		if(buf.getInt() != MerkleTree.MAGIC_HDR) {
			throw new IllegalArgumentException( "Serialized byte array does not start with appropriate Magic Header" );
		}
		
		int totnodes = buf.getInt();
		
		/* ---[ read data ]--- */
		List<byte[]> leafSigs = new ArrayList<>( (totnodes / 2) + 1 );
		
		// read root
		Node root = new Node();
		root.type = buf.get();
		if(root.type == LEAF_SIG_TYPE) {
			throw new IllegalStateException( "First serialized node is a leaf" );
		}
		
		readNextSignature( buf, root );
		
		Queue<Node> q = new ArrayDeque<>( (totnodes / 2) + 1 );
		Node curr = root;
		
		int height = 0;
		int expNumNodes = 2;
		int nodesThisLevel = 0;
		for(int i = 1; i < totnodes; i++) {
			Node child = new Node();
			child.type = buf.get();
			readNextSignature( buf, child );
			q.add( child );
			
			if(child.type == LEAF_SIG_TYPE) {
				leafSigs.add( child.sig );
			}
			
			// Handles incomplete tree where a node has been "promoted".
			if(signaturesEqual( child.sig, curr.sig )) {
				curr.left = child;
				curr = q.remove();
				expNumNodes *= 2;
				nodesThisLevel = 0;
				height++;
				continue;
			}
			
			nodesThisLevel++;
			if(curr.left == null) {
				curr.left = child;
			}
			else {
				curr.right = child;
				curr = q.remove();
				
				if(nodesThisLevel >= expNumNodes) {
					expNumNodes *= 2;
					nodesThisLevel = 0;
					height++;
				}
			}
		}
		
		return new MerkleTree( root, totnodes, height, leafSigs );
	}
	
	/**
	 * Use this method when you want to deserialize single nodes (tipically a level of the tree).
	 * Serialization format:
	 * (numnodes:int)[(siglength:int)(signature:byte[])]
	*/
	public static List<Node> deserializeNodes( final ByteBuffer data ) throws IOException
	{
		int numNodes = data.getInt();
		
		List<Node> nodes = new ArrayList<>( numNodes );
		for(int i = 0; i < numNodes; i++) {
			Node node = new Node();
			readNextSignature( data, node );
			nodes.add( node );
		}
		
		return nodes;
	}
	
	/**
	 * Returns true if the two byte arrays passed in are exactly identical.
	*/
	public static boolean signaturesEqual( final byte[] sig, final byte[] sig2 )
	{
		if(sig.length != sig2.length) {
			return false;
		}
		
		for(int i = 0; i < sig.length; i++) {
			if(sig[i] != sig2[i]) {
				return false;
			}
		}
		
		return true;
	}
	
	private static void readNextSignature( final ByteBuffer buf, final Node nd )
	{
		nd.sig = new byte[MerkleTree.sigLength];
		buf.get( nd.sig );
	}
}